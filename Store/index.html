<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ComposableArchitecture - Store</title>
    <link rel="stylesheet" type="text/css" href="/reactiveswift-composable-architecture/all.css" media="all" />
</head>
<body>
    <header>
        <a href="/reactiveswift-composable-architecture/">
            <strong>
                ComposableArchitecture
            </strong>
            <span>Documentation</span>
        </a>
    </header>

    <!--
    <form class="search">
        <input type="search" placeholder="Search" />
    </form>
    -->

    <nav>
        <div class="wrapper">
            <h2>On This Page</h2>
            <ol><li><a href="#initializers">Initializers</a><ul><li class="initializer"><a href="#store.init(initialstate:reducer:environment:)">init(initial​State:​reducer:​environment:​)</a></li></ul></li><li><a href="#properties">Properties</a><ul><li class="variable"><a href="#store.stateless">stateless</a></li><li class="variable"><a href="#store.actionless">actionless</a></li></ul></li><li><a href="#methods">Methods</a><ul><li class="function"><a href="#store.unchecked(initialstate:reducer:environment:)">unchecked(initial​State:​reducer:​environment:​)</a></li><li class="function"><a href="#store.producerscope(state:action:)">producer​Scope(state:​action:​)</a></li><li class="function"><a href="#store.producerscope(state:)">producer​Scope(state:​)</a></li><li class="function"><a href="#store.scope(state:action:)">scope(state:​action:​)</a></li><li class="function"><a href="#store.scope(state:)">scope(state:​)</a></li><li class="function"><a href="#store.iflet(then:else:)">if​Let(then:​else:​)</a></li></ul></li></ol>
        </div>
    </nav>

    <main>
        <article>
            <h1>
    <small>Class</small>
    <code class="name">Store</code>
</h1>

<div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="attribute">final</span> <span class="keyword">class</span> <span class="type">Store</span>&lt;<span class="variable">State</span>, <span class="variable">Action</span>&gt;  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>A store represents the runtime that powers the application. It is the object that you will pass
around to views that need to interact with the application.</p>

</div>
<div class="discussion">
    <p>You will typically construct a single one of these at the root of your application, and then use
the <code>scope(state:action:)</code> method to derive more focused stores that can be passed to
subviews:</p>

<html><body><pre class="highlight"><code><span class="attribute">@</span><span class="attribute">main</span>
<span class="keyword">struct</span> <span class="type">MyApp</span>: <span class="type">App</span> {
  <span class="keyword">var</span> <span class="variable">body</span>: <span class="keyword">some</span> <span class="type">Scene</span> {
    <span class="variable">WindowGroup</span> {
      <span class="variable">RootView</span>(
        <span class="variable">store</span>: <span class="type">Store</span>(
          <span class="variable">initialState</span>: <span class="type">AppState</span>(),
          <span class="variable">reducer</span>: <span class="type">appReducer</span>,
          <span class="variable">environment</span>: <span class="type">AppEnvironment</span>(
            ...
          )
        )
      )
    }
  }
}
</code></pre></body></html>
<h3>Scoping</h3>

<p>The most important operation defined on <code>Store</code> is the <code>scope(state:action:)</code> method, which
allows you to transform a store into one that deals with child state and actions. This is
necessary for passing stores to subviews that only care about a small portion of the entire
application's domain.</p>

<p>For example, if an application has a tab view at its root with tabs for activity, search, and
profile, then we can model the domain like this:</p>

<html><body><pre class="highlight"><code><span class="keyword">struct</span> <span class="type">AppState</span> {
  <span class="keyword">var</span> <span class="variable">activity</span>: <span class="type">ActivityState</span>
  <span class="keyword">var</span> <span class="variable">profile</span>: <span class="type">ProfileState</span>
  <span class="keyword">var</span> <span class="variable">search</span>: <span class="type">SearchState</span>
}

<span class="keyword">enum</span> <span class="type">AppAction</span> {
  <span class="keyword">case</span> <span class="variable">activity</span>(<span class="type">ActivityAction</span>)
  <span class="keyword">case</span> <span class="variable">profile</span>(<span class="type">ProfileAction</span>)
  <span class="keyword">case</span> <span class="variable">search</span>(<span class="type">SearchAction</span>)
}
</code></pre></body></html>
<p>We can construct a view for each of these domains by applying <code>scope(state:action:)</code> to a
store that holds onto the full app domain in order to transform it into a store for each
sub-domain:</p>

<html><body><pre class="highlight"><code><span class="keyword">struct</span> <span class="type">AppView</span>: <span class="type">View</span> {
  <span class="keyword">let</span> <span class="variable">store</span>: <span class="type">Store</span>&lt;<span class="type">AppState</span>, <span class="type">AppAction</span>&gt;

  <span class="keyword">var</span> <span class="variable">body</span>: <span class="keyword">some</span> <span class="type">View</span> {
    <span class="variable">TabView</span> {
      <span class="variable">ActivityView</span>(<span class="variable">store</span>: <span class="keyword">self</span>.<span class="variable">store</span>.<span class="variable">scope</span>(<span class="variable">state</span>: \.<span class="variable">activity</span>, <span class="variable">action</span>: <span class="type">AppAction</span>.<span class="variable">activity</span>))
        .<span class="variable">tabItem</span> { <span class="variable">Text</span>(<span class="string literal">"</span><span class="string literal">Activity</span><span class="string literal">"</span>) }

      <span class="variable">SearchView</span>(<span class="variable">store</span>: <span class="keyword">self</span>.<span class="variable">store</span>.<span class="variable">scope</span>(<span class="variable">state</span>: \.<span class="variable">search</span>, <span class="variable">action</span>: <span class="type">AppAction</span>.<span class="variable">search</span>))
        .<span class="variable">tabItem</span> { <span class="variable">Text</span>(<span class="string literal">"</span><span class="string literal">Search</span><span class="string literal">"</span>) }

      <span class="variable">ProfileView</span>(<span class="variable">store</span>: <span class="keyword">self</span>.<span class="variable">store</span>.<span class="variable">scope</span>(<span class="variable">state</span>: \.<span class="variable">profile</span>, <span class="variable">action</span>: <span class="type">AppAction</span>.<span class="variable">profile</span>))
        .<span class="variable">tabItem</span> { <span class="variable">Text</span>(<span class="string literal">"</span><span class="string literal">Profile</span><span class="string literal">"</span>) }
    }
  }
}
</code></pre></body></html>
<h3>Thread safety</h3>

<p>The <code>Store</code> class is not thread-safe, and so all interactions with an instance of <code>Store</code>
(including all of its scopes and derived <code>ViewStore</code>s) must be done on the same thread the
store was created on. Further, if the store is powering a SwiftUI or UIKit view, as is
customary, then all interactions must be done on the <em>main</em> thread.</p>

<p>The reason stores are not thread-safe is due to the fact that when an action is sent to a store,
a reducer is run on the current state, and this process cannot be done from multiple threads.
It is possible to make this process thread-safe by introducing locks or queues, but this
introduces new complications:</p>

<ul>
<li>
<p>If done simply with <code>DispatchQueue.main.async</code> you will incur a thread hop even when you are
already on the main thread. This can lead to unexpected behavior in UIKit and SwiftUI, where
sometimes you are required to do work synchronously, such as in animation blocks.</p>
</li>
<li>
<p>It is possible to create a scheduler that performs its work immediately when on the main
thread and otherwise uses <code>DispatchQueue.main.async</code> (<em>e.g.</em>, see Combine Schedulers'
<a href="https://github.com/pointfreeco/combine-schedulers/blob/main/Sources/CombineSchedulers/UIScheduler.swift">UIScheduler</a>).</p>
</li>
</ul>

<p>This introduces a lot more complexity, and should probably not be adopted without having a very
good reason.</p>

<p>This is why we require all actions be sent from the same thread. This requirement is in the same
spirit of how <code>URLSession</code> and other Apple APIs are designed. Those APIs tend to deliver their
outputs on whatever thread is most convenient for them, and then it is your responsibility to
dispatch back to the main queue if that's what you need. The Composable Architecture makes you
responsible for making sure to send actions on the main thread. If you are using an effect that
may deliver its output on a non-main thread, you must explicitly perform <code>.receive(on:)</code> in
order to force it back on the main thread.</p>

<p>This approach makes the fewest number of assumptions about how effects are created and
transformed, and prevents unnecessary thread hops and re-dispatching. It also provides some
testing benefits. If your effects are not responsible for their own scheduling, then in tests
all of the effects would run synchronously and immediately. You would not be able to test how
multiple in-flight effects interleave with each other and affect the state of your application.
However, by leaving scheduling out of the <code>Store</code> we get to test these aspects of our effects
if we so desire, or we can ignore if we prefer. We have that flexibility.</p>

<h4>Thread safety checks</h4>

<p>The store performs some basic thread safety checks in order to help catch mistakes. Stores
constructed via the initializer <code>init(initialState:reducer:environment:)</code> are assumed to run
only on the main thread, and so a check is executed immediately to make sure that is the case.
Further, all actions sent to the store and all scopes (see <code>scope(state:action:)</code>) of the
store are also checked to make sure that work is performed on the main thread.</p>

</div>

    <section id="initializers">
        <h2>Initializers</h2>

        <div role="article" class="initializer" id="store.init(initialstate:reducer:environment:)">
    <h3>
        <code><a href="#store.init(initialstate:reducer:environment:)">init(initial​State:​reducer:​environment:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="attribute">convenience</span> <span class="keyword">init</span>&lt;<span class="variable">Environment</span>&gt;(
    <span class="variable">initialState</span>: <span class="type">State</span>,
    <span class="variable">reducer</span>: <a href="/reactiveswift-composable-architecture/Reducer"><span class="type">Reducer</span></a>&lt;<span class="type">State</span>, <span class="type">Action</span>, <span class="type">Environment</span>&gt;,
    <span class="variable">environment</span>: <span class="type">Environment</span>
  )  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Initializes a store from an initial state, a reducer, and an environment.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>initial​State</th>
    <td><code class="type">State</code></td>
    <td><p>The state to start the application in.</p>
</td>
</tr>
<tr>
    <th>reducer</th>
    <td><code class="type">Reducer&lt;State, Action, Environment&gt;</code></td>
    <td><p>The reducer that powers the business logic of the application.</p>
</td>
</tr>
<tr>
    <th>environment</th>
    <td><code class="type">Environment</code></td>
    <td><p>The environment of dependencies for the application.</p>
</td>
</tr>
  </tbody>
</table>
</div>
    </section>
    <section id="properties">
        <h2>Properties</h2>

        <div role="article" class="variable" id="store.stateless">
    <h3>
        <code><a href="#store.stateless">stateless</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">var</span> <span class="variable">stateless</span>: <a href="/reactiveswift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">Void</span>, <span class="type">Action</span>&gt;  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Returns a &quot;stateless&quot; store by erasing state to <code>Void</code>.</p>

</div>
</div>
<div role="article" class="variable" id="store.actionless">
    <h3>
        <code><a href="#store.actionless">actionless</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">var</span> <span class="variable">actionless</span>: <a href="/reactiveswift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">State</span>, <span class="type">Never</span>&gt;  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Returns an &quot;actionless&quot; store by erasing action to <code>Never</code>.</p>

</div>
</div>
    </section>
    <section id="methods">
        <h2>Methods</h2>

        <div role="article" class="function" id="store.unchecked(initialstate:reducer:environment:)">
    <h3>
        <code><a href="#store.unchecked(initialstate:reducer:environment:)">unchecked(initial​State:​reducer:​environment:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">unchecked</span>&lt;<span class="variable">Environment</span>&gt;(
    <span class="variable">initialState</span>: <span class="type">State</span>,
    <span class="variable">reducer</span>: <a href="/reactiveswift-composable-architecture/Reducer"><span class="type">Reducer</span></a>&lt;<span class="type">State</span>, <span class="type">Action</span>, <span class="type">Environment</span>&gt;,
    <span class="variable">environment</span>: <span class="type">Environment</span>
  ) -&gt; <span class="keyword">Self</span>  </body></html></code></pre>
</div>
</div>
<div role="article" class="function" id="store.producerscope(state:action:)">
    <h3>
        <code><a href="#store.producerscope(state:action:)">producer​Scope(state:​action:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="attribute">@</span><span class="attribute">available</span>(
      *, <span class="variable">deprecated</span>,
      <span class="variable">message</span>:
        <span class="string literal">"""
      If you use this method, please open a discussion on GitHub and let us know how: \
      https://github.com/pointfreeco/swift-composable-architecture/discussions/new
      """</span>
    )
    <span class="keyword">public</span> <span class="keyword">func</span> <span class="function">producerScope</span>&lt;<span class="variable">ChildState</span>, <span class="variable">ChildAction</span>&gt;(
      <span class="variable">state</span> <span class="variable">toChildState</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<span class="type">SignalProducer</span>&lt;<span class="type">State</span>, <span class="type">Never</span>&gt;) -&gt; <span class="type">SignalProducer</span>&lt;
        <span class="type">ChildState</span>, <span class="type">Never</span>
      &gt;,
      <span class="variable">action</span> <span class="variable">fromChildAction</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<span class="type">ChildAction</span>) -&gt; <span class="type">Action</span>
    ) -&gt; <span class="type">SignalProducer</span>&lt;<a href="/reactiveswift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">ChildState</span>, <span class="type">ChildAction</span>&gt;, <span class="type">Never</span>&gt;  </body></html></code></pre>
</div>
</div>
<div role="article" class="function" id="store.producerscope(state:)">
    <h3>
        <code><a href="#store.producerscope(state:)">producer​Scope(state:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="attribute">@</span><span class="attribute">available</span>(
      *, <span class="variable">deprecated</span>,
      <span class="variable">message</span>:
        <span class="string literal">"""
      If you use this method, please open a discussion on GitHub and let us know how: \
      https://github.com/pointfreeco/swift-composable-architecture/discussions/new
      """</span>
    )
    <span class="keyword">public</span> <span class="keyword">func</span> <span class="function">producerScope</span>&lt;<span class="variable">ChildState</span>&gt;(
      <span class="variable">state</span> <span class="variable">toChildState</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<span class="type">SignalProducer</span>&lt;<span class="type">State</span>, <span class="type">Never</span>&gt;) -&gt; <span class="type">SignalProducer</span>&lt;
        <span class="type">ChildState</span>, <span class="type">Never</span>
      &gt;
    ) -&gt; <span class="type">SignalProducer</span>&lt;<a href="/reactiveswift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">ChildState</span>, <span class="type">Action</span>&gt;, <span class="type">Never</span>&gt;  </body></html></code></pre>
</div>
</div>
<div role="article" class="function" id="store.scope(state:action:)">
    <h3>
        <code><a href="#store.scope(state:action:)">scope(state:​action:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">scope</span>&lt;<span class="variable">ChildState</span>, <span class="variable">ChildAction</span>&gt;(
    <span class="variable">state</span> <span class="variable">toChildState</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<span class="type">State</span>) -&gt; <span class="type">ChildState</span>,
    <span class="variable">action</span> <span class="variable">fromChildAction</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<span class="type">ChildAction</span>) -&gt; <span class="type">Action</span>
  ) -&gt; <a href="/reactiveswift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">ChildState</span>, <span class="type">ChildAction</span>&gt;  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Scopes the store to one that exposes child state and actions.</p>

</div>
<div class="discussion">
    <p>This can be useful for deriving new stores to hand to child views in an application. For
example:</p>

<html><body><pre class="highlight"><code><span class="comment">// Application state made from child states.</span>
<span class="keyword">struct</span> <span class="type">AppState</span> { <span class="keyword">var</span> <span class="variable">login</span>: <span class="type">LoginState</span>, ... }
<span class="keyword">enum</span> <span class="type">AppAction</span> { <span class="keyword">case</span> <span class="variable">login</span>(<span class="type">LoginAction</span>), ... }

<span class="comment">// A store that runs the entire application.</span>
<span class="keyword">let</span> <span class="variable">store</span> = <span class="variable">Store</span>(
  <span class="variable">initialState</span>: <span class="type">AppState</span>(),
  <span class="variable">reducer</span>: <span class="type">appReducer</span>,
  <span class="variable">environment</span>: <span class="type">AppEnvironment</span>()
)

<span class="comment">// Construct a login view by scoping the store to one that works with only login domain.</span>
<span class="variable">LoginView</span>(
  <span class="variable">store</span>: <a href="/reactiveswift-composable-architecture/store"><span class="type">store</span></a>.<span class="variable">scope</span>(
    <span class="variable">state</span>: \.<span class="variable">login</span>,
    <span class="variable">action</span>: <span class="type">AppAction</span>.<span class="variable">login</span>
  )
)
</code></pre></body></html>
<p>Scoping in this fashion allows you to better modularize your application. In this case,
<code>LoginView</code> could be extracted to a module that has no access to <code>AppState</code> or <code>AppAction</code>.</p>

<p>Scoping also gives a view the opportunity to focus on just the state and actions it cares
about, even if its feature domain is larger.</p>

<p>For example, the above login domain could model a two screen login flow: a login form followed
by a two-factor authentication screen. The second screen's domain might be nested in the
first:</p>

<html><body><pre class="highlight"><code><span class="keyword">struct</span> <span class="type">LoginState</span>: <span class="type">Equatable</span> {
  <span class="keyword">var</span> <span class="variable">email</span> = <span class="string literal">"</span><span class="string literal"/><span class="string literal">"</span>
  <span class="keyword">var</span> <span class="variable">password</span> = <span class="string literal">"</span><span class="string literal"/><span class="string literal">"</span>
  <span class="keyword">var</span> <span class="variable">twoFactorAuth</span>: <span class="type">TwoFactorAuthState</span>?
}

<span class="keyword">enum</span> <span class="type">LoginAction</span>: <span class="type">Equatable</span> {
  <span class="keyword">case</span> <span class="variable">emailChanged</span>(<span class="type">String</span>)
  <span class="keyword">case</span> <span class="variable">loginButtonTapped</span>
  <span class="keyword">case</span> <span class="variable">loginResponse</span>(<span class="type">Result</span>&lt;<span class="type">TwoFactorAuthState</span>, <span class="type">LoginError</span>&gt;)
  <span class="keyword">case</span> <span class="variable">passwordChanged</span>(<span class="type">String</span>)
  <span class="keyword">case</span> <span class="variable">twoFactorAuth</span>(<span class="type">TwoFactorAuthAction</span>)
}
</code></pre></body></html>
<p>The login view holds onto a store of this domain:</p>

<html><body><pre class="highlight"><code><span class="keyword">struct</span> <span class="type">LoginView</span>: <span class="type">View</span> {
  <span class="keyword">let</span> <span class="variable">store</span>: <a href="/reactiveswift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">LoginState</span>, <span class="type">LoginAction</span>&gt;

  <span class="keyword">var</span> <span class="variable">body</span>: <span class="keyword">some</span> <span class="type">View</span> { ... }
}
</code></pre></body></html>
<p>If its body were to use a view store of the same domain, this would introduce a number of
problems:</p>

<ul>
<li>
<p>The login view would be able to read from <code>twoFactorAuth</code> state. This state is only intended
to be read from the two-factor auth screen.</p>
</li>
<li>
<p>Even worse, changes to <code>twoFactorAuth</code> state would now cause SwiftUI to recompute
<code>LoginView</code>'s body unnecessarily.</p>
</li>
<li>
<p>The login view would be able to send <code>twoFactorAuth</code> actions. These actions are only
intended to be sent from the two-factor auth screen (and reducer).</p>
</li>
<li>
<p>The login view would be able to send non user-facing login actions, like <code>loginResponse</code>.
These actions are only intended to be used in the login reducer to feed the results of
effects back into the store.</p>
</li>
</ul>

<p>To avoid these issues, one can introduce a view-specific domain that slices off the subset of
state and actions that a view cares about:</p>

<html><body><pre class="highlight"><code><span class="keyword">extension</span> <span class="type">LoginView</span> {
  <span class="keyword">struct</span> <span class="type">State</span>: <span class="type">Equatable</span> {
    <span class="keyword">var</span> <span class="variable">email</span>: <span class="type">String</span>
    <span class="keyword">var</span> <span class="variable">password</span>: <span class="type">String</span>
  }

  <span class="keyword">enum</span> <span class="type">Action</span>: <span class="type">Equatable</span> {
    <span class="keyword">case</span> <span class="variable">emailChanged</span>(<span class="type">String</span>)
    <span class="keyword">case</span> <span class="variable">loginButtonTapped</span>
    <span class="keyword">case</span> <span class="variable">passwordChanged</span>(<span class="type">String</span>)
  }
}
</code></pre></body></html>
<p>One can also introduce a couple helpers that transform feature state into view state and
transform view actions into feature actions.</p>

<html><body><pre class="highlight"><code><span class="keyword">extension</span> <span class="type">LoginState</span> {
  <span class="keyword">var</span> <span class="variable">view</span>: <span class="type">LoginView</span>.<span class="type">State</span> {
    .<span class="variable">init</span>(<span class="variable">email</span>: <span class="keyword">self</span>.<span class="variable">email</span>, <span class="variable">password</span>: <span class="keyword">self</span>.<span class="variable">password</span>)
  }
}

<span class="keyword">extension</span> <span class="type">LoginView</span>.<span class="type">Action</span> {
  <span class="keyword">var</span> <span class="variable">feature</span>: <span class="type">LoginAction</span> {
    <span class="keyword">switch</span> <span class="keyword">self</span> {
    <span class="keyword">case</span> <span class="keyword">let</span> .<span class="variable">emailChanged</span>(<span class="variable">email</span>)
      <span class="keyword">return</span> .<span class="variable">emailChanged</span>(<span class="variable">email</span>)
    <span class="keyword">case</span> .<span class="variable">loginButtonTapped</span>:
      <span class="keyword">return</span> .<span class="variable">loginButtonTapped</span>
    <span class="keyword">case</span> <span class="keyword">let</span> .<span class="variable">passwordChanged</span>(<span class="variable">password</span>)
      <span class="keyword">return</span> .<span class="variable">passwordChanged</span>(<span class="variable">password</span>)
    }
  }
}
</code></pre></body></html>
<p>With these helpers defined, <code>LoginView</code> can now scope its store's feature domain into its view
domain:</p>

<html><body><pre class="highlight"><code> <span class="keyword">var</span> <span class="variable">body</span>: <span class="keyword">some</span> <span class="type">View</span> {
   <span class="variable">WithViewStore</span>(
     <span class="keyword">self</span>.<span class="variable">store</span>, <span class="variable">observe</span>: \.<span class="variable">view</span>, <span class="variable">send</span>: \.<span class="variable">feature</span>
   ) { <span class="variable">viewStore</span> <span class="keyword">in</span>
     ...
   }
 }
</code></pre></body></html>
<p>This view store is now incapable of reading any state but view state (and will not recompute
when non-view state changes), and is incapable of sending any actions but view actions.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>to​Child​State</th>
    <td><code class="type">@escaping (State) -&gt; Child​State</code></td>
    <td><p>A function that transforms <code>State</code> into <code>ChildState</code>.</p>
</td>
</tr>
<tr>
    <th>from​Child​Action</th>
    <td><code class="type">@escaping (Child​Action) -&gt; Action</code></td>
    <td><p>A function that transforms <code>ChildAction</code> into <code>Action</code>.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A new store with its domain (state and action) transformed.</p>

</div>
<div role="article" class="function" id="store.scope(state:)">
    <h3>
        <code><a href="#store.scope(state:)">scope(state:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">scope</span>&lt;<span class="variable">ChildState</span>&gt;(
    <span class="variable">state</span> <span class="variable">toChildState</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<span class="type">State</span>) -&gt; <span class="type">ChildState</span>
  ) -&gt; <a href="/reactiveswift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">ChildState</span>, <span class="type">Action</span>&gt;  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Scopes the store to one that exposes child state.</p>

</div>
<div class="discussion">
    <p>A version of <code>scope(state:action:)</code> that leaves the action type unchanged.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>to​Child​State</th>
    <td><code class="type">@escaping (State) -&gt; Child​State</code></td>
    <td><p>A function that transforms <code>State</code> into <code>ChildState</code>.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A new store with its domain (state and action) transformed.</p>

</div>
<div role="article" class="function" id="store.iflet(then:else:)">
    <h3>
        <code><a href="#store.iflet(then:else:)">if​Let(then:​else:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="attribute">@</span><span class="attribute">discardableResult</span>
  <span class="keyword">public</span> <span class="keyword">func</span> <span class="function">ifLet</span>&lt;<span class="variable">Wrapped</span>&gt;(
    <span class="variable">then</span> <span class="variable">unwrap</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<a href="/reactiveswift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">Wrapped</span>, <span class="type">Action</span>&gt;) -&gt; <span class="type">Void</span>,
    <span class="variable">else</span>: <span class="attribute">@</span><span class="attribute">escaping</span> () -&gt; <span class="type">Void</span> = {}
  ) -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">State</span> == <span class="type">Wrapped</span>?  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Calls one of two closures depending on whether a store's optional state is <code>nil</code> or not, and
whenever this condition changes for as long as the cancellable lives.</p>

</div>
<div class="discussion">
    <p>If the store's state is non-<code>nil</code>, it will safely unwrap the value and bundle it into a new
store of non-optional state that is passed to the first closure. If the store's state is
<code>nil</code>, the second closure is called instead.</p>

<p>This method is useful for handling navigation in UIKit. The state for a screen the user wants
to navigate to can be held as an optional value in the parent, and when that value goes from
<code>nil</code> to non-<code>nil</code>, or non-<code>nil</code> to <code>nil</code>, you can update the navigation stack accordingly:</p>

<html><body><pre class="highlight"><code> <span class="keyword">class</span> <span class="type">ParentViewController</span>: <span class="type">UIViewController</span> {
   <span class="keyword">let</span> <span class="variable">store</span>: <a href="/reactiveswift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">ParentState</span>, <span class="type">ParentAction</span>&gt;
   ...
   <span class="keyword">func</span> <span class="function">viewDidLoad</span>() {
     ...
     <span class="keyword">self</span>.<span class="variable">store</span>
       .<span class="variable">scope</span>(<span class="variable">state</span>: \.<span class="variable">optionalChild</span>, <span class="variable">action</span>: <span class="type">ParentAction</span>.<span class="variable">child</span>)
       .<span class="variable">ifLet</span>(
         <span class="variable">then</span>: { [<span class="variable">weak</span> <span class="keyword">self</span>] <span class="variable">childStore</span> <span class="keyword">in</span>
           <span class="keyword">self</span>?.<span class="variable">navigationController</span>?.<span class="variable">pushViewController</span>(
             <span class="variable">ChildViewController</span>(<span class="variable">store</span>: <span class="type">childStore</span>),
             <span class="variable">animated</span>: <span class="keyword">true</span>
           )
         },
         <span class="variable">else</span>: { [<span class="variable">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span>
           <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> = <span class="keyword">self</span> <span class="keyword">else</span> { <span class="keyword">return</span> }
           <span class="keyword">self</span>.<span class="variable">navigationController</span>?.<span class="variable">popToViewController</span>(<span class="keyword">self</span>, <span class="variable">animated</span>: <span class="keyword">true</span>)
         }
       )
   }
 }
</code></pre></body></html>
</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>unwrap</th>
    <td><code class="type">@escaping (Store&lt;Wrapped, Action&gt;) -&gt; Void</code></td>
    <td><p>A function that is called with a store of non-optional state when the store's state is non-<code>nil</code>, or whenever it goes from <code>nil</code> to non-<code>nil</code>.</p>
</td>
</tr>
<tr>
    <th>else</th>
    <td><code class="type">@escaping () -&gt; Void</code></td>
    <td><p>A function that is called when the store's optional state is <code>nil</code>, or whenever it goes from non-<code>nil</code> to <code>nil</code>.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A disposable that maintains a subscription to updates whenever the store's state goes from <code>nil</code> to non-<code>nil</code> and vice versa, so that the caller can react to these changes.</p>

</div>
    </section>



        </article>
    </main>

    <footer>
        <p>
    Generated on <time datetime="2022-12-31T17:25:39+0000">December 31, 2022</time> using <a href="https://github.com/SwiftDocOrg/swift-doc">swift-doc</a> <span class="version">1.0.0-rc.1</span>.
</p>
    </footer>
</body>
</html>
